# -*- coding: utf-8 -*-
"""yenidataseti

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CP9Bm8FB9xthz1SlVO_ktpRd0_sfP_mY

# PROBLEM TANIMI

Bireyin kişisel bilgilerini kullanarak gelir düzeyinin tahmini yapılacak.

GELİR :

<=50 (0)  ,  >50 (1)

# VERİ TOPLAMA

Kaggle üzerinden hazır veri seti alındı.

https://www.kaggle.com/datasets/wenruliu/adult-income-dataset/data

# VERİ ÖN İŞLEME

Aşağıda gerekli kütüphaneleri ekledik.

**numpy:** Büyük, çok boyutlu diziler ve matrisler üzerinde hızlı matematiksel işlemler yapmak için kullanılır; veri analizi için temel bir yapı taşını oluşturur.

**pandas:** Verileri organize etmek, işlemek ve analiz etmek için güçlü DataFrame ve Series veri yapıları sağlar.

**matplotlib.pyplot:** Verilerin grafiksel olarak görselleştirilmesi için temel grafik çizim araçları sunar.

**seaborn:** Daha estetik ve karmaşık görselleştirme araçlarıyla verilerin analizine yönelik gelişmiş grafikler oluşturmak için kullanılır (Matplotlib'i temel alır).
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""Aşağıdaki kod pandas kütüphanesini kullanarak bir CSV dosyasını okumak ve içeriğini bir DataFrame'e yüklemek için kullanılır.

Okunan veriler df adlı bir değişkene atanır. df burada bir DataFrame nesnesidir. Bu nesne üzerinde çeşitli veri manipülasyonu ve analizi işlemleri yapacağız.

"""

df = pd.read_csv('data.csv')

"""Bu kod pandas kütphanesini kullanarak oluşturduğumuz dataframe'in ilk 5 satırını yazdırır.

Bu sayede veri setine genel bir bakış açısı sağladık ve veri tipleri, eksik değerler ya da sütun adları gibi detayları hızlıca incelemiş olduk.

Veri setinde ? olan yerler vardır. Bu genellikle bilinmeyen veya eksik veri anlamına gelebilir. Bunla ilgili analizi ilerleyen adımlarda bakacağız.
"""

print(df.head())

"""Bu kod veri setimizin satır ve sütun sayısını görüntülememizi sağlar.

Bu sayede veri setinin büyüklüğüne bakmış olduk.
"""

df.shape

"""Bu kod ile veri setindeki sütun adlarını görüntüledik.

"""

df.columns

"""Veriyi daha iyi anlamak için nümerik ve kategorik olarak ikiye ayırma işlemi yaptık.

Kategorik ve nümerik sütunların ne olduğunu görmüş olduk.
"""

categorical_features = [col for col in df.columns if (df[col].dtype == "object") or (df[col].dtype == "categorical")]

numerical_features = [col for col in df.columns if (df[col].dtype != "object") and (df[col].dtype != "categorical")]

categorical_features, numerical_features

"""Burada kullanmış olduğumuz info() komutu ile veri setinin genel bir yapısını inceledik ve hangi veri türleriyle çalıştığımızı görmüş olduk."""

print(df.info())

"""Veri setindeki sütunların veri tipleri hakkında bilgi edindik."""

df.dtypes

"""**DUPLİCATE VERİ ANALİZİ**

df.duplicated() komutu ile veri setimizde tekrar eden satırları tespit etmeye çalıştık.

print komutu ile de duplicate satırların toplam sayısını ekrana yazdırdık.

52 tane duplicate veri olduğunu görmüş olduk .
"""

duplicate_rows = df.duplicated()
print(duplicate_rows.sum())

"""Veri setindeki tekrar eden satırları temizleme işlemi yapıldı."""

df = df.drop_duplicates()

"""Emin olmak için tekrardan Duplicate satırları kontrol ettik.

Sonucun 0 olduğunu görerek temizlendiğine emin olmuş olduk.
"""

duplicate_rows = df.duplicated()
print(duplicate_rows.sum())

"""**48842 - 52 = 48790** olduğundan duplicate verileri temizlediğimizi gördük tekrardan."""

df.shape

"""**NULL DEĞER ANALİZİ**

Her sütundaki null değerlerin sayısına baktık .

Bütün sütunlarda null değer olmadığını gördük.

***SONUÇ:***

Veri setinde NULL değer yoktur.
"""

df.isnull().sum()

"""**'?' OLAN SEMBOLLERİN ANALİZİ**

Veri setinde ? olan satırları görüntüledik.
"""

df.isin(['?'])

"""Veri setindeki '?' sembollerinin hangi sütunlarda ve ne kadar yoğunlukta bulunduğunu tespit ettik."""

df.isin(['?']).sum()

"""Bu kodu, bir pandas DataFrame'de belirtilen sütunlardaki '?' sembollerini eksik veri (NaN) olarak değiştirmek için kullandık."""

df['workclass']=df['workclass'].replace('?',np.nan)
df['occupation']=df['occupation'].replace('?',np.nan)
df['native-country']=df['native-country'].replace('?',np.nan)

"""Yukarıda yaptığımız değiştirme işleminin sonucunda ? olan sembollerin değiştiğini görmek için tekrardan kontrol yaptık.

"""

df.isin(['?']).sum()

"""? olan sembolleri null değer yaptığımız için null değer kontrolü yapıyoruz tekrardan.

Yukarıda ? olan sembollerin sütunlardaki sayısına baktığımızda burda gördüğümüz değerler ile aynı sonuç olduğunu görmüş olduk .

Aynı zamanda buradan ? olan sembollerin hepsinin null olarak değiştiğini de anlamış olduk.
"""

df.isnull().sum()

"""Veri setindeki bu eksik değerleri temizlemeye karar verdik ve dropna komutu ile veri setimizdeki eksik verileri temizledik.

Veri setimizi görüntüleyerek bakmış olduk .
"""

df.dropna(how='any',inplace=True)
df

"""Null değerlerin kontrolünü yaparak null değerleri temizlediğimizi görmüş olduk."""

df.isnull().sum()

"""Temizleme işlemi yaptıktan sonra veri setinin boyutuna baktık.



"""

df.shape

"""Bu kod, pandas kütüphanesi kullanılarak oluşturulan bir DataFrame içindeki sayısal sütunlar için çeşitli istatistiksel özetleri sağlar."""

df.describe()

"""**KATEGORİK DEĞİŞKENLERİN ANALİZİ**"""

# 1. Kategorik değişkenleri tespit et
categorical_features = df.select_dtypes(include=['object', 'category']).columns

categorical_features

# Kategorik bir değişkendeki benzersiz değerleri gözlemlemek için unique() kullan.
unique_work=df['workclass'].unique().tolist()
print(unique_work)

unique_ed=df['education'].unique().tolist()
print(unique_ed)

unique_marital=df['marital-status'].unique().tolist()
print(unique_marital)

unique_oc=df['occupation'].unique().tolist()
print(unique_oc)

unique_re=df['relationship'].unique().tolist()
print(unique_re)

unique_ra=df['race'].unique().tolist()
print(unique_ra)

unique_ge=df['gender'].unique().tolist()
print(unique_ge)

unique_nat=df['native-country'].unique().tolist()
print(unique_nat)

unique_in=df['income'].unique().tolist()
print(unique_in)

#Her bir kategorik değişken için toplam gözlem sayısını value_counts() ile bul.
for col in categorical_features:
    print(f'{df[col].value_counts()}\n', 5*"*********")

#Kategorik değişkenlerin bar grafiğini çiz
for col in categorical_features:
    plt.figure(figsize=(8, 6))
    sns.countplot(x=col, data=df)
    plt.title(f"{col} Kategorik Değişkeninin Dağılımı")
    plt.xticks(rotation=45)  # X eksenindeki etiketlerin daha rahat okunması için
    plt.show()

# Liste haline getirilecek değişkenlerin belirlenmesi
columns_to_listify = ['workclass', 'education', 'occupation', 'race', 'gender', 'native-country', 'income']

# Her sütun için kategorik değerleri listeye çevirme
categories_dict = {col: df[col].dropna().unique().tolist() for col in columns_to_listify}

# Sonuçları kontrol etme
for col, values in categories_dict.items():
    print(f"{col} kategorileri: {values}\n")

#Her kategori kendi içinde mantık sıralamasına göre sıralar. (örn: maaş için en düşük maaştan en büyük maaşa göre sıralama gibi)
# ! label encoding için hazırlar feature engineering kısmında yapıcam !

from pandas.api.types import CategoricalDtype

# Sıralama mantığını tanımlıyoruz

workclass_order = [
    "Never-worked", "Without-pay", "Federal-gov", "Local-gov", "State-gov",
    "Self-emp-not-inc", "Self-emp-inc", "Private"
]

education_order = [
    "Preschool", "1st-4th", "5th-6th", "7th-8th", "9th", "10th", "11th", "12th",
    "HS-grad", "Some-college", "Assoc-voc", "Assoc-acdm", "Bachelors", "Masters", "Doctorate", "Prof-school"
]

marital_status_order = [
    "Never-married", "Separated", "Divorced", "Widowed", "Married-spouse-absent",
    "Married-AF-spouse", "Married-civ-spouse"
]

occupation_order = [
    "Priv-house-serv","Other-service","Handlers-cleaners","Farming-fishing","Machine-op-inspct","Transport-moving",
    "Craft-repair","Adm-clerical","Sales","Tech-support","Protective-serv","Prof-specialty","Exec-managerial","Armed-Forces"
]

relationship_order = [
    "Other-relative", "Not-in-family", "Own-child", "Unmarried", "Wife", "Husband"
]

race_order = ["Other", "Amer-Indian-Eskimo", "Asian-Pac-Islander", "Black", "White"]
gender_order = ["Female", "Male"]
income_order = ["<=50K", ">50K"]

# Değişkenleri ordinal hale getiriyoruz
df["education"] = df["education"].astype(CategoricalDtype(categories=education_order, ordered=True))
df["workclass"] = df["workclass"].astype(CategoricalDtype(categories=workclass_order, ordered=True))
df["marital-status"] = df["marital-status"].astype(CategoricalDtype(categories=marital_status_order, ordered=True))
df["occupation"] = df["occupation"].astype(CategoricalDtype(categories=occupation_order, ordered=True))
df["relationship"] = df["relationship"].astype(CategoricalDtype(categories=relationship_order, ordered=True))
df["race"] = df["race"].astype(CategoricalDtype(categories=race_order, ordered=True))
df["gender"] = df["gender"].astype(CategoricalDtype(categories=gender_order, ordered=True))
df["income"] = df["income"].astype(CategoricalDtype(categories=income_order, ordered=True))

# Eğitim seviyesini sıralı bir şekilde görmek için
sorted_df = df.sort_values("education")
print(sorted_df["education"])

"""**NÜMERİK DEĞİŞKENLERİN ANALİZİ**"""

# Veri setindeki numerik kolonları seçmek için aşağıdaki yapıyı kullanabiliriz.
df_numerical = df.select_dtypes(include = ["float64", "int64"])
df_numerical.head()

df_numerical.describe().T

# Numerik bir kolonun dağılımını görmek için histogram kullanırız.
sns.histplot(data = df, x = "age", kde = True, hue = "income");

sns.histplot(data = df, x = "educational-num", kde = True, hue = "income");

sns.histplot(data = df, x = "capital-gain", kde = True,hue = "income");

sns.histplot(data = df, x = "capital-loss", kde = True, hue = "income");

# Compute the correlation matrix for numerical columns
correlation_matrix = df_numerical.corr()

# Plot the correlation matrix as a heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix')
plt.show()

"""**AYKIRI DEĞER ANALİZİ**"""

df_age = df['age']

# Quantile değerlerin belirlenmesi.
Q1 = df_age.quantile(0.25)
Q3 = df_age.quantile(0.75)

print("Q1:",Q1)
print("Q3:",Q3)

# IQR değerin belirlenmesi.
IQR = Q3-Q1
print("IQR:",IQR)

# Alt ve üst sınırların belirlenmesi.
lower_fence = Q1 - 1.5*IQR
upper_fence = Q3 + 1.5*IQR

print("Alt Sınır (Lower Fence):", lower_fence)
print("Üst Sınır (Upper Fence):", upper_fence)

df = df.copy()
# Bir değişkendeki IQR'a göre aykırı gözlemleri boxplot kullanarak görselleştirelim.
plt.figure(figsize = (8, 6))
sns.boxplot(data = df,
            y = df["age"],
            orient = "v");

plt.axhline(y=upper_fence, color='r', linestyle='--', label=f"Üst Sınır: {upper_fence:.2f}")
plt.axhline(y=lower_fence, color='b', linestyle='--', label=f"Alt Sınır: {lower_fence:.2f}")
plt.legend()
plt.show()

print(f"Satır Sayısı: {len(df)}")

# Upper_fence üzerinde kalan aykırı gözlemlerin index değerlerini, daha sonra kullanmak üzere bir değişkende tutabiliriz.
outlier_idx = df_age[df_age > upper_fence].index

outlier_idx

df_del = df[~(df_age > upper_fence)]

df_del

print(f"Satır Sayısı: {len(df_del)}")

plt.figure(figsize = (8, 6))
sns.boxplot(data = df_del,
            y = df_del["age"],
            orient = "v");

print(f"Satır Sayısı: {len(df_del)}")

df_educational_num = df['educational-num']

# Quantile değerlerin belirlenmesi.
Q1 = df_educational_num.quantile(0.25)
Q3 = df_educational_num.quantile(0.75)

print("Q1:",Q1)
print("Q3:",Q3)

# IQR değerin belirlenmesi.
IQR = Q3-Q1
print("IQR:",IQR)

# Alt ve üst sınırların belirlenmesi.
lower_fence = Q1 - 1.5*IQR
upper_fence = Q3 + 1.5*IQR

print("Alt Sınır (Lower Fence):", lower_fence)
print("Üst Sınır (Upper Fence):", upper_fence)

df = df.copy()
# Bir değişkendeki IQR'a göre aykırı gözlemleri boxplot kullanarak görselleştirelim.
plt.figure(figsize = (8, 6))
sns.boxplot(data = df,
            y = df["educational-num"],
            orient = "v");

plt.axhline(y=upper_fence, color='r', linestyle='--', label=f"Üst Sınır: {upper_fence:.2f}")
plt.axhline(y=lower_fence, color='b', linestyle='--', label=f"Alt Sınır: {lower_fence:.2f}")
plt.legend()
plt.show()

print(f"Satır Sayısı: {len(df_del)}")

# lower_fence altında kalan aykırı gözlemlerin index değerlerini, daha sonra kullanmak üzere bir değişkende tutabiliriz.
outlier_idx = df_educational_num[df_educational_num < lower_fence].index

outlier_idx

df_del = df[~(df_educational_num < lower_fence)]

df_del

print(f"Satır Sayısı: {len(df_del)}")

plt.figure(figsize = (8, 6))
sns.boxplot(data = df_del,
            y = df_del["educational-num"],
            orient = "v");

print(f"Satır Sayısı: {len(df_del)}")

# Sıfır olmayan 'capital-gain' değerlerini filtreleme
df_capital_gain = df['capital-gain']
df_non_zero = df_capital_gain[df_capital_gain > 0]

# Quantile değerlerin belirlenmesi
Q1 = df_non_zero.quantile(0.25)
Q3 = df_non_zero.quantile(0.75)

print("Q1:", Q1)
print("Q3:", Q3)

# IQR değerin belirlenmesi
IQR = Q3 - Q1
print("IQR:", IQR)

# Alt ve üst sınırların belirlenmesi
lower_fence = Q1 - 1.5 * IQR
upper_fence = Q3 + 1.5 * IQR

print("Alt Sınır (Lower Fence):", lower_fence)
print("Üst Sınır (Upper Fence):", upper_fence)

# Sıfır olmayan 'capital-gain' değerlerini filtreleme
df_non_zero = df[df['capital-gain'] > 0]

# Q1, Q3 ve IQR hesaplama
Q1_non_zero = df_non_zero['capital-gain'].quantile(0.25)
Q3_non_zero = df_non_zero['capital-gain'].quantile(0.75)
IQR_non_zero = Q3_non_zero - Q1_non_zero

# Alt ve üst sınırların hesaplanması
lower_fence_non_zero = Q1_non_zero - 1.5 * IQR_non_zero
upper_fence_non_zero = Q3_non_zero + 1.5 * IQR_non_zero

# Boxplot ile görselleştirme
plt.figure(figsize=(8, 6))
sns.boxplot(data=df_non_zero, y='capital-gain', orient='v')
plt.title("Boxplot of 'capital-gain' (Sıfır Olmayan Değerler)")
plt.axhline(y=upper_fence_non_zero, color='r', linestyle='--', label=f"Üst Sınır: {upper_fence_non_zero:.2f}")
plt.axhline(y=lower_fence_non_zero, color='b', linestyle='--', label=f"Alt Sınır: {lower_fence_non_zero:.2f}")
plt.legend()
plt.show()

print(f"Satır Sayısı: {len(df_del)}")

# Upper_fence üzerinde kalan aykırı gözlemlerin index değerlerini, daha sonra kullanmak üzere bir değişkende tutabiliriz.
outlier_idx = df_non_zero[df_non_zero['capital-gain'] > upper_fence].index

outlier_idx

# Sıfır olmayan 'capital-gain' değerlerini filtreleme
df_non_zero = df_del[df_del['capital-gain'] > 0]

# Q1, Q3 ve IQR hesaplama
Q1_non_zero = df_non_zero['capital-gain'].quantile(0.25)
Q3_non_zero = df_non_zero['capital-gain'].quantile(0.75)
IQR_non_zero = Q3_non_zero - Q1_non_zero

# Alt ve üst sınırların hesaplanması
lower_fence_non_zero = Q1_non_zero - 1.5 * IQR_non_zero
upper_fence_non_zero = Q3_non_zero + 1.5 * IQR_non_zero

# Aykırı değerlerin index'lerini bulma
outlier_idx = df_non_zero[df_non_zero['capital-gain'] > upper_fence_non_zero].index

# Aykırı değerleri çıkararak df_del'i güncelleme
df_del = df_del.drop(index=outlier_idx)

# Güncellenmiş veri setinin boyutunu kontrol etme
print(f"Aykırı değerler çıkarıldıktan sonraki veri seti boyutu: {df_del.shape[0]}")

# Güncellenmiş df_del'i gösterme
df_del

print(f"Satır Sayısı: {len(df_del)}")

# Sıfır olmayan 'capital-gain' değerlerini içeren df_del'i filtreleme
df_non_zero = df_del[df_del['capital-gain'] > 0]

# Boxplot ile sıfır olmayan değerlerin görselleştirilmesi
plt.figure(figsize=(8, 6))
sns.boxplot(data=df_non_zero, y='capital-gain', orient='v')
plt.title("Boxplot of 'capital-gain' (Sıfır Olmayan Değerler - Aykırı Değerler Çıkarıldı)")
plt.show()

print(f"Satır Sayısı: {len(df_del)}")

# Sıfır olmayan 'capital-loss' değerlerini filtreleme
df_capital_loss = df['capital-loss']
df_non_zero = df_capital_loss[df_capital_loss > 0]

# Quantile değerlerin belirlenmesi
Q1 = df_non_zero.quantile(0.25)
Q3 = df_non_zero.quantile(0.75)

print("Q1:", Q1)
print("Q3:", Q3)

# IQR değerin belirlenmesi
IQR = Q3 - Q1
print("IQR:", IQR)

# Alt ve üst sınırların belirlenmesi
lower_fence = Q1 - 1.5 * IQR
upper_fence = Q3 + 1.5 * IQR

print("Alt Sınır (Lower Fence):", lower_fence)
print("Üst Sınır (Upper Fence):", upper_fence)

# Sıfır olmayan 'capital-loss' değerlerini filtreleme
df_non_zero = df[df['capital-loss'] > 0]

# Q1, Q3 ve IQR hesaplama
Q1_non_zero = df_non_zero['capital-loss'].quantile(0.25)
Q3_non_zero = df_non_zero['capital-loss'].quantile(0.75)
IQR_non_zero = Q3_non_zero - Q1_non_zero

# Alt ve üst sınırların hesaplanması
lower_fence_non_zero = Q1_non_zero - 1.5 * IQR_non_zero
upper_fence_non_zero = Q3_non_zero + 1.5 * IQR_non_zero

# Boxplot ile görselleştirme
plt.figure(figsize=(8, 6))
sns.boxplot(data=df_non_zero, y='capital-loss', orient='v')
plt.title("Boxplot of 'capital-loss' (Sıfır Olmayan Değerler)")
plt.axhline(y=upper_fence_non_zero, color='r', linestyle='--', label=f"Üst Sınır: {upper_fence_non_zero:.2f}")
plt.axhline(y=lower_fence_non_zero, color='b', linestyle='--', label=f"Alt Sınır: {lower_fence_non_zero:.2f}")
plt.legend()
plt.show()

print(f"Satır Sayısı: {len(df_del)}")

# Upper_fence üzerinde kalan ve lower_fence altında kalan aykırı gözlemlerin index değerlerini, daha sonra kullanmak üzere bir değişkende tutabiliriz.
outlier_idx = df_capital_loss[(df_capital_loss > upper_fence) | (df_capital_loss < lower_fence)].index

outlier_idx

# Sıfır olmayan 'capital-loss' değerlerini filtreleme
df_non_zero = df_del[df_del['capital-loss'] > 0]

# Q1, Q3 ve IQR hesaplama
Q1_non_zero = df_non_zero['capital-loss'].quantile(0.25)
Q3_non_zero = df_non_zero['capital-loss'].quantile(0.75)
IQR_non_zero = Q3_non_zero - Q1_non_zero

# Alt ve üst sınırların hesaplanması
lower_fence_non_zero = Q1_non_zero - 1.5 * IQR_non_zero
upper_fence_non_zero = Q3_non_zero + 1.5 * IQR_non_zero

# Aykırı değerlerin index'lerini bulma (alt sınırın altı ve üst sınırın üstü)
outlier_idx = df_non_zero[
    (df_non_zero['capital-loss'] > upper_fence_non_zero) |
    (df_non_zero['capital-loss'] < lower_fence_non_zero)
].index

# Aykırı değerleri çıkararak df_del'i güncelleme
df_del = df_del.drop(index=outlier_idx)

# Güncellenmiş veri setinin boyutunu kontrol etme
print(f"Aykırı değerler çıkarıldıktan sonraki veri seti boyutu: {df_del.shape[0]}")

# Güncellenmiş df_del'i gösterme
df_del

print(f"Satır Sayısı: {len(df_del)}")

# Sıfır olmayan 'capital-loss' değerlerini içeren df_del'i filtreleme
df_non_zero = df_del[df_del['capital-loss'] > 0]

# Boxplot ile sıfır olmayan değerlerin görselleştirilmesi
plt.figure(figsize=(8, 6))
sns.boxplot(data=df_non_zero, y='capital-loss', orient='v')
plt.title("Boxplot of 'capital-loss' (Sıfır Olmayan Değerler - Aykırı Değerler Çıkarıldı)")
plt.show()

print(f"Satır Sayısı: {len(df_del)}")

"""**VERİ ÖLÇEKLEME**

**NORMALİZASYON**

**Age sütununu normalize etmek istemedik. Çünkü yaş değerleri çok uç değerler ifade etmiyordu.**
"""

from sklearn.preprocessing import MinMaxScaler

# Min-Max Scaler nesnesini oluşturma
scaler = MinMaxScaler()

# Sayısal sütunları seçme
numeric_columns = df_del.select_dtypes(include=['float64', 'int64']).columns
numeric_columns = numeric_columns.drop('age')  # 'age' sütununu çıkar

# Min-Max Scaling uygulama
df_del = df_del.copy()
df_del[numeric_columns] = scaler.fit_transform(df_del[numeric_columns])

# Sonuçları gösterme
print("Min-Max Scaling uygulandıktan sonra veri seti:")
print(df_del.head())

# Orijinal ve ölçeklendirilmiş veriyi kontrol etmek için
print("Orijinal Veri:")
print(df_del[numeric_columns].head())

print("Normalize Edilmiş Veri:")
print(df_del[numeric_columns].head())

print(f"Satır Sayısı: {len(df_del)}")

"""**ENCODİNG**"""

from pandas.api.types import CategoricalDtype

# Sıralama mantığını yukarıda kategorik verilerin analizinde tanımlamıştık.

# Kategorik sütunlara sıralamaları uygulama ve encoding yapma
df_del['workclass'] = df_del['workclass'].astype(CategoricalDtype(categories=workclass_order, ordered=True)).cat.codes
df_del['education'] = df_del['education'].astype(CategoricalDtype(categories=education_order, ordered=True)).cat.codes
df_del['marital-status'] = df_del['marital-status'].astype(CategoricalDtype(categories=marital_status_order, ordered=True)).cat.codes
df_del['occupation'] = df_del['occupation'].astype(CategoricalDtype(categories=occupation_order, ordered=True)).cat.codes
df_del['relationship'] = df_del['relationship'].astype(CategoricalDtype(categories=relationship_order, ordered=True)).cat.codes
df_del['race'] = df_del['race'].astype(CategoricalDtype(categories=race_order, ordered=True)).cat.codes
df_del['gender'] = df_del['gender'].astype(CategoricalDtype(categories=gender_order, ordered=True)).cat.codes
df_del['income'] = df_del['income'].astype(CategoricalDtype(categories=income_order, ordered=True)).cat.codes

# Sonucu kontrol etme
print(df_del.head())


print(f"Satır Sayısı: {len(df_del)}")

#Her bir kategorik değişken için toplam gözlem sayısını value_counts() ile bul.
for col in categorical_features:
    print(f'{df_del[col].value_counts()}\n', 5*"*********")

print(f"Satır Sayısı: {len(df_del)}")

"""**native country kısmını ayrı yaptık 40 tane ülke adı olduğu için.**

**100 ün altında olanları other olarak tanımladık.**
"""

from pandas.api.types import CategoricalDtype
# 1. Frekansları hesapla (value_counts)
counts = df_del['native-country'].value_counts()

# 2. Frekansı 100'ün altında olanları "Other" olarak değiştir
# Daha verimli map fonksiyonu kullanımı
threshold = 100
df_del['native-country'] = df_del['native-country'].map(lambda x: x if counts[x] >= threshold else 'Other')

# 3. Alfabetik sıraya göre benzersiz değerlerin sıralanması
native_country_order = sorted(df_del['native-country'].unique())

# 4. Native-country için kategorik dönüşüm ve encoding
native_country_dtype = CategoricalDtype(categories=native_country_order, ordered=True)
df_del['native-country'] = df_del['native-country'].astype(native_country_dtype).cat.codes

# 5. Encoding sonucunda ülke ve kod eşleştirmesi
native_country_mapping = {code: country for code, country in enumerate(native_country_order)}

# 6. Sonuçları yazdırma
print("Encoding Sonucu:")
for code, country in native_country_mapping.items():
    print(f"{country}: {code}")

# 7. Güncellenmiş sütunu kontrol etme
print("\nGüncellenmiş df_del 'native-country' sütunu:")
print(df_del['native-country'].head())

print(f"Satır Sayısı: {len(df_del)}")

df_del.head()

# Compute the correlation matrix for numerical columns
correlation_matrix = df_del.corr()

# Plot the correlation matrix as a heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix')
plt.show()

"""**education & educational-num:** Pozitif güçlü korelasyon (1.00). Eğitim seviyesi ve eğitim sayısal değeri arasında güçlü bir ilişki var.

**marital-status & relationship:** Pozitif güçlü korelasyon (0.88). Medeni durum ve akraba sayısal değeri arasında güçlü bir ilişki var.

Bu sütunlar arasında çıkarma işlemi yaptık.
"""

# 'marital-status' ve 'educational-num' sütunlarını çıkarma
df_del = df_del.drop(columns=['marital-status', 'educational-num'])

# Güncellenmiş veri setini kontrol etme
print("Güncellenmiş sütunlar:")
print(df_del.columns)

print(f"Satır Sayısı: {len(df_del)}")

# df_del veri setini CSV dosyası olarak kaydetme
output_file = "df_del_cleaned.csv"  # Kaydedilecek dosyanın adı
df_del.to_csv(output_file, index=False)

"""# KEŞİFSEL VERİ ANALİZİ

**Tek Değişkenli ve Çok Değişkenli Analiz**
"""

# Yaşları kategorilere ayırma fonksiyonu
def categorize_age(age):
    if age <= 18:
        return '0-18'
    elif age <= 30:
        return '19-30'
    elif age <= 50:
        return '30-50'
    elif age <= 65:
        return '50-65'
    else:
        return '65+'

# Yaş gruplarını oluşturma
age_groups = df_del['age'].apply(categorize_age)

# Yaş gruplarına göre yüzdelik dağılım
age_distribution = age_groups.value_counts(normalize=True).sort_index()

# Yığılmış bar grafiği çizimi
age_distribution.plot(kind='barh', color='skyblue', figsize=(8, 5))
plt.xlabel('Proportion')
plt.ylabel('Age Group')
plt.title('Age Group Distribution')
plt.tight_layout()
plt.show()

# Yaşları kategorilere ayırma fonksiyonu
def categorize_age(age):
    if age <= 18:
        return '0-18'
    elif age <= 30:
        return '19-30'
    elif age <= 50:
        return '30-50'
    elif age <= 65:
        return '50-65'
    else:
        return '65+'

# Income'ı etiketlerle eşleştiren bir fonksiyon
def map_income_label(value):
    return '<=50' if value == 0 else '>50'

# Yaş gruplarına ve gelir etiketlerine göre gruplama
grouped_data = df_del.groupby(df_del['age'].apply(categorize_age))['income'].value_counts(normalize=True).unstack().fillna(0)

# Income etiketlerini değiştirme (yalnızca görselleştirme için)
grouped_data.columns = grouped_data.columns.map(map_income_label)

# Yığılmış bar grafiği çizimi
grouped_data.plot(kind='barh', stacked=True, color=['skyblue', 'orange'])
plt.xlabel('Proportion')
plt.ylabel('Age Group')
plt.title('Income Distribution by Age Group')
plt.legend(title='Income', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

# 'workclass' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
workclass_mapping = {
    0: "Never-worked",
    1: "Without-pay",
    2: "Federal-gov",
    3: "Local-gov",
    4: "State-gov",
    5: "Self-emp-not-inc",
    6: "Self-emp-inc",
    7: "Private"
}

# Çalışma sınıflarını anlamlı isimlere çevirme
workclass_groups = df_del['workclass'].map(workclass_mapping)

# Çalışma sınıflarının yüzdelik dağılımını hesaplama
workclass_distribution = workclass_groups.value_counts(normalize=True).sort_index()

# Yığılmış bar grafiği çizimi
workclass_distribution.plot(kind='barh', color='lightgreen', figsize=(8, 5))
plt.xlabel('Proportion')
plt.ylabel('Working Class')
plt.title('Working Class Distribution')
plt.tight_layout()
plt.show()

# 'workclass' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
workclass_mapping = {
    0: "Never-worked",
    1: "Without-pay",
    2: "Federal-gov",
    3: "Local-gov",
    4: "State-gov",
    5: "Self-emp-not-inc",
    6: "Self-emp-inc",
    7: "Private"
}

# Income'ı etiketlerle eşleştiren bir fonksiyon
def map_income_label(value):
    return '<=50' if value == 0 else '>50'

# 'workclass' sütununu anlamlı isimlerle eşleme ve yüzdelik dağılım
income_distribution = df_del.groupby(df_del['workclass'].map(workclass_mapping))['income'].value_counts(normalize=True).unstack(fill_value=0)

# Income etiketlerini değiştirme (yalnızca görselleştirme için)
income_distribution.columns = income_distribution.columns.map(map_income_label)

# Encoding sırasına göre çalışma sınıflarını sıralama
ordered_workclasses = [workclass_mapping[i] for i in sorted(workclass_mapping.keys())]
income_distribution = income_distribution.reindex(ordered_workclasses)

# Yığılmış bar grafiği çizimi
plt.figure(figsize=(10, 6))
income_distribution.plot(kind='barh', stacked=True, color=['skyblue', 'orange'])
plt.xlabel('Proportion')
plt.ylabel('Working Class')
plt.title('Income Distribution by Working Class')
plt.legend(title='Income', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

#'education' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
education_mapping = {
    0: "Preschool",
    1: "1st-4th",
    2: "5th-6th",
    3: "7th-8th",
    4: "9th",
    5: "10th",
    6: "11th",
    7: "12th",
    8: "HS-grad",
    9: "Some-college",
    10: "Assoc-voc",
    11: "Assoc-acdm",
    12: "Bachelors",
    13: "Masters",
    14: "Doctorate",
    15: "Prof-school"
}

# Eğitim seviyelerini anlamlı isimlere çevirme
education_groups = df_del['education'].map(education_mapping)

# Eğitim seviyelerinin yüzdelik dağılımını hesaplama
education_distribution = education_groups.value_counts(normalize=True)

# Eğitim seviyelerini sıralama (mapping sırasına göre)
ordered_education = [education_mapping[i] for i in sorted(education_mapping.keys())]
education_distribution = education_distribution.reindex(ordered_education)

# Yığılmış bar grafiği çizimi
education_distribution.plot(kind='barh', color='cornflowerblue', figsize=(8, 5))
plt.xlabel('Proportion')
plt.ylabel('Education Level')
plt.title('Education Level Distribution')
plt.tight_layout()
plt.show()

# 'education' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
education_mapping = {
    0: "Preschool",
    1: "1st-4th",
    2: "5th-6th",
    3: "7th-8th",
    4: "9th",
    5: "10th",
    6: "11th",
    7: "12th",
    8: "HS-grad",
    9: "Some-college",
    10: "Assoc-voc",
    11: "Assoc-acdm",
    12: "Bachelors",
    13: "Masters",
    14: "Doctorate",
    15: "Prof-school"
}

# Income'ı etiketlerle eşleştiren bir fonksiyon
def map_income_label(value):
    return '<=50' if value == 0 else '>50'

# 'education' sütununu anlamlı isimlere eşleme ve yüzdelik dağılım
income_distribution = df_del.groupby(df_del['education'].map(education_mapping))['income'].value_counts(normalize=True).unstack()

# Income etiketlerini değiştirme (yalnızca görselleştirme için)
income_distribution.columns = income_distribution.columns.map(map_income_label)

# Encoding sırasına göre eğitim seviyelerini sıralama
income_distribution = income_distribution.reindex([education_mapping[i] for i in sorted(education_mapping.keys())])

# Yığılmış bar grafiği çizimi
plt.figure(figsize=(10, 6))
income_distribution.plot(kind='barh', stacked=True, color=['skyblue', 'orange'])
plt.xlabel('Proportion')
plt.ylabel('Education Level')
plt.title('Income Distribution by Education Level')
plt.legend(title='Income', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

# 'relationship' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
relationship_mapping = {
    0: "Other-relative",
    1: "Not-in-family",
    2: "Own-child",
    3: "Unmarried",
    4: "Wife",
    5: "Husband"
}

# Relationship kategorilerini anlamlı isimlere çevirme
relationship_groups = df_del['relationship'].map(relationship_mapping)

# Relationship seviyelerinin yüzdelik dağılımını hesaplama
relationship_distribution = relationship_groups.value_counts(normalize=True)

# Relationship seviyelerini sıralama (mapping sırasına göre)
ordered_relationships = [relationship_mapping[i] for i in sorted(relationship_mapping.keys())]
relationship_distribution = relationship_distribution.reindex(ordered_relationships)

# Yığılmış bar grafiği çizimi
relationship_distribution.plot(kind='barh', color='lightcoral', figsize=(8, 5))
plt.xlabel('Proportion')
plt.ylabel('Relationship')
plt.title('Relationship Distribution')
plt.tight_layout()
plt.show()

# 'relationship' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
relationship_mapping = {
    0: "Other-relative",
    1: "Not-in-family",
    2: "Own-child",
    3: "Unmarried",
    4: "Wife",
    5: "Husband"
}

# Income'ı etiketlerle eşleştiren bir fonksiyon
def map_income_label(value):
    return '<=50' if value == 0 else '>50'

# 'relationship' sütununu anlamlı isimlerle eşleme ve yüzdelik dağılım
income_distribution = df_del.groupby(df_del['relationship'].map(relationship_mapping))['income'].value_counts(normalize=True).unstack()

# Income etiketlerini değiştirme (yalnızca görselleştirme için)
income_distribution.columns = income_distribution.columns.map(map_income_label)

# Mertebe sırasına göre yeniden düzenleme
ordered_relationships = [relationship_mapping[i] for i in sorted(relationship_mapping.keys())]
income_distribution = income_distribution.reindex(ordered_relationships)

# Yığılmış bar grafiği çizimi
plt.figure(figsize=(10, 6))
income_distribution.plot(kind='barh', stacked=True, color=['skyblue', 'orange'])
plt.xlabel('Proportion')
plt.ylabel('Relationship')
plt.title('Income Distribution by Relationship')
plt.legend(title='Income', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

# 'occupation' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
occupation_mapping = {
    0: "Tech-support",
    1: "Craft-repair",
    2: "Other-service",
    3: "Sales",
    4: "Exec-managerial",
    5: "Prof-specialty",
    6: "Handlers-cleaners",
    7: "Machine-op-inspct",
    8: "Adm-clerical",
    9: "Farming-fishing",
    10: "Transport-moving",
    11: "Priv-house-serv",
    12: "Protective-serv",
    13: "Armed-Forces"
}

# Occupation kategorilerini anlamlı isimlere çevirme
occupation_groups = df_del['occupation'].map(occupation_mapping)

# Occupation seviyelerinin yüzdelik dağılımını hesaplama
occupation_distribution = occupation_groups.value_counts(normalize=True)

# Occupation seviyelerini sıralama (mapping sırasına göre)
ordered_occupations = [occupation_mapping[i] for i in sorted(occupation_mapping.keys())]
occupation_distribution = occupation_distribution.reindex(ordered_occupations)

# Yığılmış bar grafiği çizimi
occupation_distribution.plot(kind='barh', color='mediumpurple', figsize=(10, 7))
plt.xlabel('Proportion')
plt.ylabel('Occupation')
plt.title('Occupation Distribution')
plt.tight_layout()
plt.show()

# 'occupation' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
occupation_mapping = {
    0: "Priv-house-serv",
    1: "Other-service",
    2: "Handlers-cleaners",
    3: "Farming-fishing",
    4: "Machine-op-inspct",
    5: "Transport-moving",
    6: "Craft-repair",
    7: "Adm-clerical",
    8: "Sales",
    9: "Tech-support",
    10: "Protective-serv",
    11: "Prof-specialty",
    12: "Exec-managerial",
    13: "Armed-Forces"
}

# Income'ı etiketlerle eşleştiren bir fonksiyon
def map_income_label(value):
    return '<=50' if value == 0 else '>50'

# 'occupation' sütununu anlamlı isimlerle eşleme ve yüzdelik dağılım
income_distribution = df_del.groupby(df_del['occupation'].map(occupation_mapping))['income'].value_counts(normalize=True).unstack()

# Income etiketlerini değiştirme (yalnızca görselleştirme için)
income_distribution.columns = income_distribution.columns.map(map_income_label)

# Encoding sırasına göre meslekleri sıralama
ordered_occupations = [occupation_mapping[i] for i in sorted(occupation_mapping.keys())]
income_distribution = income_distribution.reindex(ordered_occupations)

# Yığılmış bar grafiği çizimi
plt.figure(figsize=(10, 6))
income_distribution.plot(kind='barh', stacked=True, color=['skyblue', 'orange'])
plt.xlabel('Proportion')
plt.ylabel('Occupation')
plt.title('Income Distribution by Occupation')
plt.legend(title='Income', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

# 'race' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
race_mapping = {
    0: "Other",
    1: "Amer-Indian-Eskimo",
    2: "Asian-Pac-Islander",
    3: "Black",
    4: "White"
}

# Irk kategorilerini anlamlı isimlere çevirme
race_groups = df_del['race'].map(race_mapping)

# Irk seviyelerinin yüzdelik dağılımını hesaplama
race_distribution = race_groups.value_counts(normalize=True)

# Irk seviyelerini sıralama (mapping sırasına göre)
ordered_races = [race_mapping[i] for i in sorted(race_mapping.keys())]
race_distribution = race_distribution.reindex(ordered_races)

# Yığılmış bar grafiği çizimi
race_distribution.plot(kind='barh', color='salmon', figsize=(8, 5))
plt.xlabel('Proportion')
plt.ylabel('Race')
plt.title('Race Distribution')
plt.tight_layout()
plt.show()

# 'race' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
race_mapping = {
    0: "Other",
    1: "Amer-Indian-Eskimo",
    2: "Asian-Pac-Islander",
    3: "Black",
    4: "White"
}

# Income'ı etiketlerle eşleştiren bir fonksiyon
def map_income_label(value):
    return '<=50' if value == 0 else '>50'

# 'race' sütununu anlamlı isimlerle eşleme ve yüzdelik dağılım
income_distribution = df_del.groupby(df_del['race'].map(race_mapping))['income'].value_counts(normalize=True).unstack()

# Income etiketlerini değiştirme (yalnızca görselleştirme için)
income_distribution.columns = income_distribution.columns.map(map_income_label)

# Encoding sırasına göre ırkları sıralama
ordered_races = [race_mapping[i] for i in sorted(race_mapping.keys())]
income_distribution = income_distribution.reindex(ordered_races)

# Yığılmış bar grafiği çizimi
plt.figure(figsize=(10, 6))
income_distribution.plot(kind='barh', stacked=True, color=['skyblue', 'orange'])
plt.xlabel('Proportion')
plt.ylabel('Race')
plt.title('Income Distribution by Race')
plt.legend(title='Income', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

# 'gender' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
gender_mapping = {
    0: "Female",
    1: "Male"
}

# Gender kategorilerini anlamlı isimlere çevirme
gender_groups = df_del['gender'].map(gender_mapping)

# Gender seviyelerinin yüzdelik dağılımını hesaplama
gender_distribution = gender_groups.value_counts(normalize=True)

# Gender seviyelerini sıralama (mapping sırasına göre)
ordered_genders = [gender_mapping[i] for i in sorted(gender_mapping.keys())]
gender_distribution = gender_distribution.reindex(ordered_genders)

# Yığılmış bar grafiği çizimi
gender_distribution.plot(kind='barh', color='dodgerblue', figsize=(8, 5))
plt.xlabel('Proportion')
plt.ylabel('Gender')
plt.title('Gender Distribution')
plt.tight_layout()
plt.show()

#'gender' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
gender_mapping = {
    0: "Female",
    1: "Male"
}

# Income'ı etiketlerle eşleştiren bir fonksiyon
def map_income_label(value):
    return '<=50' if value == 0 else '>50'

# 'gender' sütununu anlamlı isimlerle eşleme ve yüzdelik dağılım
income_distribution = df_del.groupby(df_del['gender'].map(gender_mapping))['income'].value_counts(normalize=True).unstack()

# Income etiketlerini değiştirme (yalnızca görselleştirme için)
income_distribution.columns = income_distribution.columns.map(map_income_label)

# Encoding sırasına göre cinsiyetleri sıralama
ordered_genders = [gender_mapping[i] for i in sorted(gender_mapping.keys())]
income_distribution = income_distribution.reindex(ordered_genders)

# Yığılmış bar grafiği çizimi
plt.figure(figsize=(8, 5))
income_distribution.plot(kind='barh', stacked=True, color=['skyblue', 'orange'])
plt.xlabel('Proportion')
plt.ylabel('Gender')
plt.title('Income Distribution by Gender')
plt.legend(title='Income', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

# 'native-country' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
native_country_mapping = {
    0: "Canada",
    1: "China",
    2: "Cuba",
    3: "El-Salvador",
    4: "England",
    5: "Germany",
    6: "India",
    7: "Jamaica",
    8: "Mexico",
    9: "Other",
    10: "Philippines",
    11: "Puerto-Rico",
    12: "South",
    13: "United-States"
}

# Native Country kategorilerini anlamlı isimlere çevirme
native_country_groups = df_del['native-country'].map(native_country_mapping)

# Native Country seviyelerinin yüzdelik dağılımını hesaplama
native_country_distribution = native_country_groups.value_counts(normalize=True)

# Native Country seviyelerini sıralama (mapping sırasına göre)
ordered_countries = [native_country_mapping[i] for i in sorted(native_country_mapping.keys())]
native_country_distribution = native_country_distribution.reindex(ordered_countries)

# Yığılmış bar grafiği çizimi
native_country_distribution.plot(kind='barh', color='mediumseagreen', figsize=(10, 8))
plt.xlabel('Proportion')
plt.ylabel('Native Country')
plt.title('Native Country Distribution')
plt.tight_layout()
plt.show()

# 'native-country' sütunu için kodlanmış değerleri anlamlı isimlere çeviren eşleme
native_country_mapping = {
    0: "Canada",
    1: "China",
    2: "Cuba",
    3: "El-Salvador",
    4: "England",
    5: "Germany",
    6: "India",
    7: "Jamaica",
    8: "Mexico",
    9: "Other",
    10: "Philippines",
    11: "Puerto-Rico",
    12: "South",
    13: "United-States"
}

# Income'ı etiketlerle eşleştiren bir fonksiyon
def map_income_label(value):
    return '<=50' if value == 0 else '>50'

# 'native-country' sütununu anlamlı isimlerle eşleme ve yüzdelik dağılım
income_distribution = df_del.groupby(df_del['native-country'].map(native_country_mapping))['income'].value_counts(normalize=True).unstack()

# Income etiketlerini değiştirme (yalnızca görselleştirme için)
income_distribution.columns = income_distribution.columns.map(map_income_label)

# Encoding sırasına göre native country kategorilerini sıralama
ordered_countries = [native_country_mapping[i] for i in sorted(native_country_mapping.keys())]
income_distribution = income_distribution.reindex(ordered_countries)

# Yığılmış bar grafiği çizimi (Y ekseni: Native Country, X ekseni: Proportion)
plt.figure(figsize=(12, 8))
income_distribution.plot(kind='barh', stacked=True, colormap='viridis')
plt.xlabel('Proportion')
plt.ylabel('Native Country')
plt.title('Income Distribution by Native Country')
plt.legend(title='Income', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

# Normalleştirilmiş çalışma saatlerini kategorilere ayırma fonksiyonu
def categorize_normalized_hours(hours):
    if hours <= 0.25:
        return "0.0-0.25"
    elif hours <= 0.5:
        return "0.26-0.5"
    elif hours <= 0.75:
        return "0.51-0.75"
    else:
        return "0.76-1.0"

# Normalleştirilmiş çalışma saatlerini kategorilere ayırma
normalized_hours_groups = df_del['hours-per-week'].apply(categorize_normalized_hours)

# Çalışma saatleri kategorilerinin yüzdelik dağılımını hesaplama
normalized_hours_distribution = normalized_hours_groups.value_counts(normalize=True).sort_index()

# Bar grafiği çizimi
normalized_hours_distribution.plot(kind='barh', color='tomato', figsize=(8, 5))
plt.xlabel('Proportion')
plt.ylabel('Hours per Week (Normalized)')
plt.title('Hours per Week Distribution (Normalized)')
plt.tight_layout()
plt.show()

# hours-per-week Vs income
plt.figure(figsize=(10, 3))
sns.violinplot(x='income', y='hours-per-week', data=df_del, palette='muted')
plt.xlabel('Income')
plt.ylabel('Hours per Week')
plt.title('Violin Plot of Hours per Week vs Income')
plt.xticks([0, 1], ['<=50K', '>50K'])
plt.tight_layout()
plt.show()

# Gelir dağılımı yüzdesini hesaplama
income_distribution = df_del['income'].value_counts(normalize=True)

# Gelir kategorileri
income_labels = ['<=50', '>50']

# Pasta grafiği çizimi
plt.figure(figsize=(8, 6))
plt.pie(income_distribution, labels=income_labels, autopct='%1.1f%%', startangle=90, colors=['skyblue', 'orange'])
plt.title('Income Distribution')
plt.axis('equal')  # Pasta grafiğini daire olarak tutar
plt.show()

# Compute the correlation matrix for numerical columns
correlation_matrix = df_del.corr()

# Plot the correlation matrix as a heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix')
plt.show()

"""**Bütun sütunlar hakkında varyasyon kat sayısı değerini verir.**

Varyasyon katsayısı; standart sapmanın ortalamaya göre yüzde kaçlık bir değişim gösterdiğini belirtir
"""

coefficient_of_variation = df_del.std() / df_del.mean()
print(coefficient_of_variation*100)

sorted_cv = coefficient_of_variation.sort_values()
sorted_cv.plot.barh(x = 'Variables', y = 'Coefficient of Variation', color = '#967bb6')

"""Bu kodlar, veri setindeki değişkenlerin çarpıklık (skewness) ve basıklı(kurtosis) analizini yaparak, değişkenlerin dağılım özelliklerini değerlendirmek, normal dağılıma uygunluklarını test etmek ve anormal durumları tespit etmek için kullanılmıştır."""

from tabulate import tabulate
from scipy.stats import skew, kurtosis, normaltest, shapiro

skewness = df_del.skew()
kurtosisness = df_del.kurtosis()

headers = ['Variable', 'Shapiro Test', 'Skewness C.', 'Skewness', 'Kurtosis C.', 'Kurtosis']

table_data = []
for col in df_del.columns:
    stat, p = normaltest(df_del[col])
    skewness_val = f'{skewness[col]:.4f}'
    skewness_desc = 'High skewness' if skewness[col] < -1 or skewness[col] > 1 else 'Symmetric or slightly skewed'
    kurtosis_val = f'{kurtosisness[col]:.4f}'
    kurtosis_desc = 'Very flat or peaked' if kurtosisness[col] < -2 or kurtosisness[col] > 2 else 'Normal or slightly flat'

    stat_sh, p_sh = shapiro(df_del[col])
    shapiro_test = 'Yes' if p_sh >= 0.05 else 'No'

    table_data.append([col, shapiro_test, skewness_val, skewness_desc, kurtosis_val, kurtosis_desc])

table = tabulate(table_data, headers, tablefmt='pretty')
print(table)

"""# VERİ MODELLEME

***EĞİTİM VE TEST OLARAK VERİYİ İKİYE AYIRDIK.***
"""

from sklearn.model_selection import train_test_split

# Hedef değişken ve özellikler
X = df_del.drop(columns=['income'])
y = df_del['income']

# Veriyi %80 eğitim ve %20 test olarak ayırma işlemi
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, stratify=y, random_state=42
)

# Sonuçları kontrol etme
print(f"Eğitim veri boyutu: {X_train.shape}")
print(f"Test veri boyutu: {X_test.shape}")
print(f"Eğitim setindeki income dağılımı:\n{y_train.value_counts(normalize=True)}")
print(f"Test setindeki income dağılımı:\n{y_test.value_counts(normalize=True)}")

"""**Stratified K Fold Cross Validation OLUŞTURMA**"""

from sklearn.model_selection import StratifiedKFold

# Stratified K-Fold oluşturma
kf = StratifiedKFold(n_splits=10, shuffle=True, random_state=42)

# K-Fold içinde eğitim ve validasyon gruplarını inceleme
for fold, (train_idx, val_idx) in enumerate(kf.split(X_train, y_train)):
    print(f"Fold {fold+1}")
    print(f"Eğitim seti boyutu: {len(train_idx)}")
    print(f"Validasyon seti boyutu: {len(val_idx)}")
    print(f"Eğitim setindeki income dağılımı:\n{y_train.iloc[train_idx].value_counts(normalize=True)}")
    print(f"Validasyon setindeki income dağılımı:\n{y_train.iloc[val_idx].value_counts(normalize=True)}\n")
    print("-" * 30)

"""***ÇAPRAZ DOĞRULAMA***"""

from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_curve, auc, confusion_matrix, ConfusionMatrixDisplay

# Model oluşturma
model = XGBClassifier(random_state=42)
fold_metrics = []
mean_fpr = np.linspace(0, 1, 100)
tprs = []
aucs = []

for fold, (train_idx, val_idx) in enumerate(kf.split(X_train, y_train)):
    print(f"Fold {fold+1}")

    # Eğitim ve validasyon verilerini ayır
    X_train_fold, X_val_fold = X_train.iloc[train_idx], X_train.iloc[val_idx]
    y_train_fold, y_val_fold = y_train.iloc[train_idx], y_train.iloc[val_idx]

    # Modeli eğit
    model.fit(X_train_fold, y_train_fold)

    # Validasyon seti üzerinde tahmin yap
    y_val_pred = model.predict(X_val_fold)
    y_val_proba = model.predict_proba(X_val_fold)[:, 1]  # Pozitif sınıf için olasılıklar

    # Performans metriklerini hesapla
    accuracy = accuracy_score(y_val_fold, y_val_pred)
    precision = precision_score(y_val_fold, y_val_pred, average='binary')
    recall = recall_score(y_val_fold, y_val_pred, average='binary')
    f1 = f1_score(y_val_fold, y_val_pred, average='binary')
    fold_metrics.append({'accuracy': accuracy, 'precision': precision, 'recall': recall, 'f1': f1})

    # ROC eğrisi için değerler
    fpr, tpr, _ = roc_curve(y_val_fold, y_val_proba)
    tprs.append(np.interp(mean_fpr, fpr, tpr))
    tprs[-1][0] = 0.0
    roc_auc = auc(fpr, tpr)
    aucs.append(roc_auc)

    # Sonuçları yazdır
    print(f" Fold {fold+1} doğruluk skoru (Accuracy): {accuracy:.4f}")
    print(f" Fold {fold+1} kesinlik (Precision): {precision:.4f}")
    print(f" Fold {fold+1} duyarlılık (Recall): {recall:.4f}")
    print(f" Fold {fold+1} F1 Skoru: {f1:.4f}")
    print("-" * 30)

# Tüm fold'ların sonuçlarının analizi
print("Cross Validation Sonuçları:")
average_metrics = {
    'accuracy': sum(metric['accuracy'] for metric in fold_metrics) / len(fold_metrics),
    'precision': sum(metric['precision'] for metric in fold_metrics) / len(fold_metrics),
    'recall': sum(metric['recall'] for metric in fold_metrics) / len(fold_metrics),
    'f1': sum(metric['f1'] for metric in fold_metrics) / len(fold_metrics),
}

print(f"Ortalama doğruluk skoru (Accuracy): {average_metrics['accuracy']:.4f}")
print(f"Ortalama kesinlik (Precision): {average_metrics['precision']:.4f}")
print(f"Ortalama duyarlılık (Recall): {average_metrics['recall']:.4f}")
print(f"Ortalama F1 Skoru: {average_metrics['f1']:.4f}")

# ROC eğrisi görselleştirmesi
plt.figure(figsize=(10, 8))
for i, (fpr, tpr, auc_val) in enumerate(zip(tprs, tprs, aucs)):
    plt.plot(mean_fpr, tpr, lw=1, alpha=0.3, label=f'ROC Fold {i+1} (AUC = {auc_val:.2f})')

mean_tpr = np.mean(tprs, axis=0)
mean_tpr[-1] = 1.0
mean_auc = auc(mean_fpr, mean_tpr)
plt.plot(mean_fpr, mean_tpr, color='b', lw=2, alpha=0.8, label=f'Mean ROC (AUC = {mean_auc:.2f})')

plt.plot([0, 1], [0, 1], linestyle='--', color='r', lw=2, label='Chance')
plt.xlim([-0.01, 1.01])
plt.ylim([-0.01, 1.01])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic (ROC) Curve')
plt.legend(loc='lower right')
plt.show()

"""# MODEL DEĞERLENDİRME"""

from sklearn.metrics import (
    classification_report,
    confusion_matrix,
    ConfusionMatrixDisplay
)

# Nihai test verisi üzerinde tahmin yap
y_test_pred = model.predict(X_test)

# Performans metriklerini hesapla
test_accuracy = accuracy_score(y_test, y_test_pred)
test_precision = precision_score(y_test, y_test_pred, average='binary')
test_recall = recall_score(y_test, y_test_pred, average='binary')
test_f1 = f1_score(y_test, y_test_pred, average='binary')

# Sonuçları yazdır
print("Test Verisi Performansı:")
print(f"Doğruluk Skoru (Accuracy): {test_accuracy:.4f}")
print(f"Kesinlik (Precision): {test_precision:.4f}")
print(f"Duyarlılık (Recall): {test_recall:.4f}")
print(f"F1 Skoru: {test_f1:.4f}")
print("\nDetaylı Sınıflandırma Raporu:")
print(classification_report(y_test, y_test_pred))

# Confusion Matrix Görselleştirilmesi
disp = ConfusionMatrixDisplay.from_predictions(y_test, y_test_pred, cmap=plt.cm.Blues)
plt.title("Confusion Matrix")
plt.show()